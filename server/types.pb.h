// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_types_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_types_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_types_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_types_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_types_2eproto;
namespace types {
class Block;
class BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class FoodBlock;
class FoodBlockDefaultTypeInternal;
extern FoodBlockDefaultTypeInternal _FoodBlock_default_instance_;
class Player;
class PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class PlayerBlock;
class PlayerBlockDefaultTypeInternal;
extern PlayerBlockDefaultTypeInternal _PlayerBlock_default_instance_;
class Portal;
class PortalDefaultTypeInternal;
extern PortalDefaultTypeInternal _Portal_default_instance_;
class PortalBlock;
class PortalBlockDefaultTypeInternal;
extern PortalBlockDefaultTypeInternal _PortalBlock_default_instance_;
class QueueItem;
class QueueItemDefaultTypeInternal;
extern QueueItemDefaultTypeInternal _QueueItem_default_instance_;
class UserScore;
class UserScoreDefaultTypeInternal;
extern UserScoreDefaultTypeInternal _UserScore_default_instance_;
class WallBlock;
class WallBlockDefaultTypeInternal;
extern WallBlockDefaultTypeInternal _WallBlock_default_instance_;
}  // namespace types
PROTOBUF_NAMESPACE_OPEN
template<> ::types::Block* Arena::CreateMaybeMessage<::types::Block>(Arena*);
template<> ::types::FoodBlock* Arena::CreateMaybeMessage<::types::FoodBlock>(Arena*);
template<> ::types::Player* Arena::CreateMaybeMessage<::types::Player>(Arena*);
template<> ::types::PlayerBlock* Arena::CreateMaybeMessage<::types::PlayerBlock>(Arena*);
template<> ::types::Portal* Arena::CreateMaybeMessage<::types::Portal>(Arena*);
template<> ::types::PortalBlock* Arena::CreateMaybeMessage<::types::PortalBlock>(Arena*);
template<> ::types::QueueItem* Arena::CreateMaybeMessage<::types::QueueItem>(Arena*);
template<> ::types::UserScore* Arena::CreateMaybeMessage<::types::UserScore>(Arena*);
template<> ::types::WallBlock* Arena::CreateMaybeMessage<::types::WallBlock>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace types {

enum Action : int {
  UP = 0,
  RIGHT = 1,
  DOWN = 2,
  LEFT = 3,
  Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Action_IsValid(int value);
constexpr Action Action_MIN = UP;
constexpr Action Action_MAX = LEFT;
constexpr int Action_ARRAYSIZE = Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Action_descriptor();
template<typename T>
inline const std::string& Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Action_descriptor(), enum_t_value);
}
inline bool Action_Parse(
    const std::string& name, Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Action>(
    Action_descriptor(), name, value);
}
// ===================================================================

class UserScore :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.UserScore) */ {
 public:
  UserScore();
  virtual ~UserScore();

  UserScore(const UserScore& from);
  UserScore(UserScore&& from) noexcept
    : UserScore() {
    *this = ::std::move(from);
  }

  inline UserScore& operator=(const UserScore& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserScore& operator=(UserScore&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserScore& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserScore* internal_default_instance() {
    return reinterpret_cast<const UserScore*>(
               &_UserScore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(UserScore* other);
  friend void swap(UserScore& a, UserScore& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserScore* New() const final {
    return CreateMaybeMessage<UserScore>(nullptr);
  }

  UserScore* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserScore>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserScore& from);
  void MergeFrom(const UserScore& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserScore* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.UserScore";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2eproto);
    return ::descriptor_table_types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // uint64 score = 2;
  void clear_score();
  static const int kScoreFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 score() const;
  void set_score(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:types.UserScore)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 score_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class QueueItem :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.QueueItem) */ {
 public:
  QueueItem();
  virtual ~QueueItem();

  QueueItem(const QueueItem& from);
  QueueItem(QueueItem&& from) noexcept
    : QueueItem() {
    *this = ::std::move(from);
  }

  inline QueueItem& operator=(const QueueItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueueItem& operator=(QueueItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QueueItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueueItem* internal_default_instance() {
    return reinterpret_cast<const QueueItem*>(
               &_QueueItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(QueueItem* other);
  friend void swap(QueueItem& a, QueueItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueueItem* New() const final {
    return CreateMaybeMessage<QueueItem>(nullptr);
  }

  QueueItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueueItem>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QueueItem& from);
  void MergeFrom(const QueueItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueueItem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.QueueItem";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2eproto);
    return ::descriptor_table_types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint32 occupied = 2;
  void clear_occupied();
  static const int kOccupiedFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 occupied() const;
  void set_occupied(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 size = 3;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:types.QueueItem)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 occupied_;
  ::PROTOBUF_NAMESPACE_ID::uint32 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class Block :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block& operator=(Block&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Block& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Block* other);
  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Block* New() const final {
    return CreateMaybeMessage<Block>(nullptr);
  }

  Block* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.Block";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2eproto);
    return ::descriptor_table_types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:types.Block)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 x_;
  ::PROTOBUF_NAMESPACE_ID::uint32 y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class PlayerBlock :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.PlayerBlock) */ {
 public:
  PlayerBlock();
  virtual ~PlayerBlock();

  PlayerBlock(const PlayerBlock& from);
  PlayerBlock(PlayerBlock&& from) noexcept
    : PlayerBlock() {
    *this = ::std::move(from);
  }

  inline PlayerBlock& operator=(const PlayerBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerBlock& operator=(PlayerBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerBlock* internal_default_instance() {
    return reinterpret_cast<const PlayerBlock*>(
               &_PlayerBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PlayerBlock* other);
  friend void swap(PlayerBlock& a, PlayerBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerBlock* New() const final {
    return CreateMaybeMessage<PlayerBlock>(nullptr);
  }

  PlayerBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerBlock>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerBlock& from);
  void MergeFrom(const PlayerBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerBlock* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.PlayerBlock";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2eproto);
    return ::descriptor_table_types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .types.Block position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::types::Block& position() const;
  ::types::Block* release_position();
  ::types::Block* mutable_position();
  void set_allocated_position(::types::Block* position);

  // @@protoc_insertion_point(class_scope:types.PlayerBlock)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::types::Block* position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class Player :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.Player) */ {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Player& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Player* other);
  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Player* New() const final {
    return CreateMaybeMessage<Player>(nullptr);
  }

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.Player";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2eproto);
    return ::descriptor_table_types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.PlayerBlock blocks = 4;
  int blocks_size() const;
  void clear_blocks();
  static const int kBlocksFieldNumber = 4;
  ::types::PlayerBlock* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::PlayerBlock >*
      mutable_blocks();
  const ::types::PlayerBlock& blocks(int index) const;
  ::types::PlayerBlock* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::PlayerBlock >&
      blocks() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // .types.PlayerBlock head = 3;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 3;
  const ::types::PlayerBlock& head() const;
  ::types::PlayerBlock* release_head();
  ::types::PlayerBlock* mutable_head();
  void set_allocated_head(::types::PlayerBlock* head);

  // bool is_alive = 2;
  void clear_is_alive();
  static const int kIsAliveFieldNumber = 2;
  bool is_alive() const;
  void set_is_alive(bool value);

  // @@protoc_insertion_point(class_scope:types.Player)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::PlayerBlock > blocks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::types::PlayerBlock* head_;
  bool is_alive_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class FoodBlock :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.FoodBlock) */ {
 public:
  FoodBlock();
  virtual ~FoodBlock();

  FoodBlock(const FoodBlock& from);
  FoodBlock(FoodBlock&& from) noexcept
    : FoodBlock() {
    *this = ::std::move(from);
  }

  inline FoodBlock& operator=(const FoodBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline FoodBlock& operator=(FoodBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FoodBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FoodBlock* internal_default_instance() {
    return reinterpret_cast<const FoodBlock*>(
               &_FoodBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(FoodBlock* other);
  friend void swap(FoodBlock& a, FoodBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FoodBlock* New() const final {
    return CreateMaybeMessage<FoodBlock>(nullptr);
  }

  FoodBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FoodBlock>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FoodBlock& from);
  void MergeFrom(const FoodBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FoodBlock* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.FoodBlock";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2eproto);
    return ::descriptor_table_types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .types.Block position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::types::Block& position() const;
  ::types::Block* release_position();
  ::types::Block* mutable_position();
  void set_allocated_position(::types::Block* position);

  // uint32 benefit = 2;
  void clear_benefit();
  static const int kBenefitFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 benefit() const;
  void set_benefit(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:types.FoodBlock)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::types::Block* position_;
  ::PROTOBUF_NAMESPACE_ID::uint32 benefit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class WallBlock :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.WallBlock) */ {
 public:
  WallBlock();
  virtual ~WallBlock();

  WallBlock(const WallBlock& from);
  WallBlock(WallBlock&& from) noexcept
    : WallBlock() {
    *this = ::std::move(from);
  }

  inline WallBlock& operator=(const WallBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline WallBlock& operator=(WallBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WallBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WallBlock* internal_default_instance() {
    return reinterpret_cast<const WallBlock*>(
               &_WallBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(WallBlock* other);
  friend void swap(WallBlock& a, WallBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WallBlock* New() const final {
    return CreateMaybeMessage<WallBlock>(nullptr);
  }

  WallBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WallBlock>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WallBlock& from);
  void MergeFrom(const WallBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WallBlock* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.WallBlock";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2eproto);
    return ::descriptor_table_types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .types.Block position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::types::Block& position() const;
  ::types::Block* release_position();
  ::types::Block* mutable_position();
  void set_allocated_position(::types::Block* position);

  // @@protoc_insertion_point(class_scope:types.WallBlock)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::types::Block* position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class PortalBlock :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.PortalBlock) */ {
 public:
  PortalBlock();
  virtual ~PortalBlock();

  PortalBlock(const PortalBlock& from);
  PortalBlock(PortalBlock&& from) noexcept
    : PortalBlock() {
    *this = ::std::move(from);
  }

  inline PortalBlock& operator=(const PortalBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortalBlock& operator=(PortalBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PortalBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PortalBlock* internal_default_instance() {
    return reinterpret_cast<const PortalBlock*>(
               &_PortalBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(PortalBlock* other);
  friend void swap(PortalBlock& a, PortalBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PortalBlock* New() const final {
    return CreateMaybeMessage<PortalBlock>(nullptr);
  }

  PortalBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PortalBlock>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PortalBlock& from);
  void MergeFrom(const PortalBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortalBlock* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.PortalBlock";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2eproto);
    return ::descriptor_table_types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .types.Block position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::types::Block& position() const;
  ::types::Block* release_position();
  ::types::Block* mutable_position();
  void set_allocated_position(::types::Block* position);

  // @@protoc_insertion_point(class_scope:types.PortalBlock)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::types::Block* position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class Portal :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.Portal) */ {
 public:
  Portal();
  virtual ~Portal();

  Portal(const Portal& from);
  Portal(Portal&& from) noexcept
    : Portal() {
    *this = ::std::move(from);
  }

  inline Portal& operator=(const Portal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Portal& operator=(Portal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Portal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Portal* internal_default_instance() {
    return reinterpret_cast<const Portal*>(
               &_Portal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Portal* other);
  friend void swap(Portal& a, Portal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Portal* New() const final {
    return CreateMaybeMessage<Portal>(nullptr);
  }

  Portal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Portal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Portal& from);
  void MergeFrom(const Portal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Portal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.Portal";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_types_2eproto);
    return ::descriptor_table_types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .types.PortalBlock peer_1 = 1;
  bool has_peer_1() const;
  void clear_peer_1();
  static const int kPeer1FieldNumber = 1;
  const ::types::PortalBlock& peer_1() const;
  ::types::PortalBlock* release_peer_1();
  ::types::PortalBlock* mutable_peer_1();
  void set_allocated_peer_1(::types::PortalBlock* peer_1);

  // .types.PortalBlock peer_2 = 2;
  bool has_peer_2() const;
  void clear_peer_2();
  static const int kPeer2FieldNumber = 2;
  const ::types::PortalBlock& peer_2() const;
  ::types::PortalBlock* release_peer_2();
  ::types::PortalBlock* mutable_peer_2();
  void set_allocated_peer_2(::types::PortalBlock* peer_2);

  // @@protoc_insertion_point(class_scope:types.Portal)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::types::PortalBlock* peer_1_;
  ::types::PortalBlock* peer_2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserScore

// string name = 1;
inline void UserScore::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& UserScore::name() const {
  // @@protoc_insertion_point(field_get:types.UserScore.name)
  return name_.GetNoArena();
}
inline void UserScore::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.UserScore.name)
}
inline void UserScore::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.UserScore.name)
}
inline void UserScore::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.UserScore.name)
}
inline void UserScore::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.UserScore.name)
}
inline std::string* UserScore::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:types.UserScore.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserScore::release_name() {
  // @@protoc_insertion_point(field_release:types.UserScore.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserScore::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:types.UserScore.name)
}

// uint64 score = 2;
inline void UserScore::clear_score() {
  score_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UserScore::score() const {
  // @@protoc_insertion_point(field_get:types.UserScore.score)
  return score_;
}
inline void UserScore::set_score(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:types.UserScore.score)
}

// -------------------------------------------------------------------

// QueueItem

// uint64 id = 1;
inline void QueueItem::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 QueueItem::id() const {
  // @@protoc_insertion_point(field_get:types.QueueItem.id)
  return id_;
}
inline void QueueItem::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:types.QueueItem.id)
}

// uint32 occupied = 2;
inline void QueueItem::clear_occupied() {
  occupied_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 QueueItem::occupied() const {
  // @@protoc_insertion_point(field_get:types.QueueItem.occupied)
  return occupied_;
}
inline void QueueItem::set_occupied(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  occupied_ = value;
  // @@protoc_insertion_point(field_set:types.QueueItem.occupied)
}

// uint32 size = 3;
inline void QueueItem::clear_size() {
  size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 QueueItem::size() const {
  // @@protoc_insertion_point(field_get:types.QueueItem.size)
  return size_;
}
inline void QueueItem::set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:types.QueueItem.size)
}

// -------------------------------------------------------------------

// Block

// uint32 x = 1;
inline void Block::clear_x() {
  x_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Block::x() const {
  // @@protoc_insertion_point(field_get:types.Block.x)
  return x_;
}
inline void Block::set_x(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:types.Block.x)
}

// uint32 y = 2;
inline void Block::clear_y() {
  y_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Block::y() const {
  // @@protoc_insertion_point(field_get:types.Block.y)
  return y_;
}
inline void Block::set_y(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:types.Block.y)
}

// -------------------------------------------------------------------

// PlayerBlock

// .types.Block position = 1;
inline bool PlayerBlock::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline void PlayerBlock::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::types::Block& PlayerBlock::position() const {
  const ::types::Block* p = position_;
  // @@protoc_insertion_point(field_get:types.PlayerBlock.position)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::Block*>(
      &::types::_Block_default_instance_);
}
inline ::types::Block* PlayerBlock::release_position() {
  // @@protoc_insertion_point(field_release:types.PlayerBlock.position)
  
  ::types::Block* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::types::Block* PlayerBlock::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::Block>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.PlayerBlock.position)
  return position_;
}
inline void PlayerBlock::set_allocated_position(::types::Block* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:types.PlayerBlock.position)
}

// -------------------------------------------------------------------

// Player

// string name = 1;
inline void Player::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Player::name() const {
  // @@protoc_insertion_point(field_get:types.Player.name)
  return name_.GetNoArena();
}
inline void Player::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Player.name)
}
inline void Player::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Player.name)
}
inline void Player::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Player.name)
}
inline void Player::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Player.name)
}
inline std::string* Player::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:types.Player.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Player::release_name() {
  // @@protoc_insertion_point(field_release:types.Player.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:types.Player.name)
}

// bool is_alive = 2;
inline void Player::clear_is_alive() {
  is_alive_ = false;
}
inline bool Player::is_alive() const {
  // @@protoc_insertion_point(field_get:types.Player.is_alive)
  return is_alive_;
}
inline void Player::set_is_alive(bool value) {
  
  is_alive_ = value;
  // @@protoc_insertion_point(field_set:types.Player.is_alive)
}

// .types.PlayerBlock head = 3;
inline bool Player::has_head() const {
  return this != internal_default_instance() && head_ != nullptr;
}
inline void Player::clear_head() {
  if (GetArenaNoVirtual() == nullptr && head_ != nullptr) {
    delete head_;
  }
  head_ = nullptr;
}
inline const ::types::PlayerBlock& Player::head() const {
  const ::types::PlayerBlock* p = head_;
  // @@protoc_insertion_point(field_get:types.Player.head)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::PlayerBlock*>(
      &::types::_PlayerBlock_default_instance_);
}
inline ::types::PlayerBlock* Player::release_head() {
  // @@protoc_insertion_point(field_release:types.Player.head)
  
  ::types::PlayerBlock* temp = head_;
  head_ = nullptr;
  return temp;
}
inline ::types::PlayerBlock* Player::mutable_head() {
  
  if (head_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::PlayerBlock>(GetArenaNoVirtual());
    head_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.Player.head)
  return head_;
}
inline void Player::set_allocated_head(::types::PlayerBlock* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:types.Player.head)
}

// repeated .types.PlayerBlock blocks = 4;
inline int Player::blocks_size() const {
  return blocks_.size();
}
inline void Player::clear_blocks() {
  blocks_.Clear();
}
inline ::types::PlayerBlock* Player::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:types.Player.blocks)
  return blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::PlayerBlock >*
Player::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:types.Player.blocks)
  return &blocks_;
}
inline const ::types::PlayerBlock& Player::blocks(int index) const {
  // @@protoc_insertion_point(field_get:types.Player.blocks)
  return blocks_.Get(index);
}
inline ::types::PlayerBlock* Player::add_blocks() {
  // @@protoc_insertion_point(field_add:types.Player.blocks)
  return blocks_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::PlayerBlock >&
Player::blocks() const {
  // @@protoc_insertion_point(field_list:types.Player.blocks)
  return blocks_;
}

// -------------------------------------------------------------------

// FoodBlock

// .types.Block position = 1;
inline bool FoodBlock::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline void FoodBlock::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::types::Block& FoodBlock::position() const {
  const ::types::Block* p = position_;
  // @@protoc_insertion_point(field_get:types.FoodBlock.position)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::Block*>(
      &::types::_Block_default_instance_);
}
inline ::types::Block* FoodBlock::release_position() {
  // @@protoc_insertion_point(field_release:types.FoodBlock.position)
  
  ::types::Block* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::types::Block* FoodBlock::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::Block>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.FoodBlock.position)
  return position_;
}
inline void FoodBlock::set_allocated_position(::types::Block* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:types.FoodBlock.position)
}

// uint32 benefit = 2;
inline void FoodBlock::clear_benefit() {
  benefit_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FoodBlock::benefit() const {
  // @@protoc_insertion_point(field_get:types.FoodBlock.benefit)
  return benefit_;
}
inline void FoodBlock::set_benefit(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  benefit_ = value;
  // @@protoc_insertion_point(field_set:types.FoodBlock.benefit)
}

// -------------------------------------------------------------------

// WallBlock

// .types.Block position = 1;
inline bool WallBlock::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline void WallBlock::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::types::Block& WallBlock::position() const {
  const ::types::Block* p = position_;
  // @@protoc_insertion_point(field_get:types.WallBlock.position)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::Block*>(
      &::types::_Block_default_instance_);
}
inline ::types::Block* WallBlock::release_position() {
  // @@protoc_insertion_point(field_release:types.WallBlock.position)
  
  ::types::Block* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::types::Block* WallBlock::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::Block>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.WallBlock.position)
  return position_;
}
inline void WallBlock::set_allocated_position(::types::Block* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:types.WallBlock.position)
}

// -------------------------------------------------------------------

// PortalBlock

// .types.Block position = 1;
inline bool PortalBlock::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline void PortalBlock::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::types::Block& PortalBlock::position() const {
  const ::types::Block* p = position_;
  // @@protoc_insertion_point(field_get:types.PortalBlock.position)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::Block*>(
      &::types::_Block_default_instance_);
}
inline ::types::Block* PortalBlock::release_position() {
  // @@protoc_insertion_point(field_release:types.PortalBlock.position)
  
  ::types::Block* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::types::Block* PortalBlock::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::Block>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.PortalBlock.position)
  return position_;
}
inline void PortalBlock::set_allocated_position(::types::Block* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:types.PortalBlock.position)
}

// -------------------------------------------------------------------

// Portal

// .types.PortalBlock peer_1 = 1;
inline bool Portal::has_peer_1() const {
  return this != internal_default_instance() && peer_1_ != nullptr;
}
inline void Portal::clear_peer_1() {
  if (GetArenaNoVirtual() == nullptr && peer_1_ != nullptr) {
    delete peer_1_;
  }
  peer_1_ = nullptr;
}
inline const ::types::PortalBlock& Portal::peer_1() const {
  const ::types::PortalBlock* p = peer_1_;
  // @@protoc_insertion_point(field_get:types.Portal.peer_1)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::PortalBlock*>(
      &::types::_PortalBlock_default_instance_);
}
inline ::types::PortalBlock* Portal::release_peer_1() {
  // @@protoc_insertion_point(field_release:types.Portal.peer_1)
  
  ::types::PortalBlock* temp = peer_1_;
  peer_1_ = nullptr;
  return temp;
}
inline ::types::PortalBlock* Portal::mutable_peer_1() {
  
  if (peer_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::PortalBlock>(GetArenaNoVirtual());
    peer_1_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.Portal.peer_1)
  return peer_1_;
}
inline void Portal::set_allocated_peer_1(::types::PortalBlock* peer_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete peer_1_;
  }
  if (peer_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      peer_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_1, submessage_arena);
    }
    
  } else {
    
  }
  peer_1_ = peer_1;
  // @@protoc_insertion_point(field_set_allocated:types.Portal.peer_1)
}

// .types.PortalBlock peer_2 = 2;
inline bool Portal::has_peer_2() const {
  return this != internal_default_instance() && peer_2_ != nullptr;
}
inline void Portal::clear_peer_2() {
  if (GetArenaNoVirtual() == nullptr && peer_2_ != nullptr) {
    delete peer_2_;
  }
  peer_2_ = nullptr;
}
inline const ::types::PortalBlock& Portal::peer_2() const {
  const ::types::PortalBlock* p = peer_2_;
  // @@protoc_insertion_point(field_get:types.Portal.peer_2)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::PortalBlock*>(
      &::types::_PortalBlock_default_instance_);
}
inline ::types::PortalBlock* Portal::release_peer_2() {
  // @@protoc_insertion_point(field_release:types.Portal.peer_2)
  
  ::types::PortalBlock* temp = peer_2_;
  peer_2_ = nullptr;
  return temp;
}
inline ::types::PortalBlock* Portal::mutable_peer_2() {
  
  if (peer_2_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::PortalBlock>(GetArenaNoVirtual());
    peer_2_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.Portal.peer_2)
  return peer_2_;
}
inline void Portal::set_allocated_peer_2(::types::PortalBlock* peer_2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete peer_2_;
  }
  if (peer_2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      peer_2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_2, submessage_arena);
    }
    
  } else {
    
  }
  peer_2_ = peer_2;
  // @@protoc_insertion_point(field_set_allocated:types.Portal.peer_2)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace types

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::types::Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::types::Action>() {
  return ::types::Action_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_types_2eproto
